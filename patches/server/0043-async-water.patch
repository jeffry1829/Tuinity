From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: jeffry1829 <jeffry1829@gmail.com>
Date: Wed, 29 Apr 2020 20:59:57 +0800
Subject: [PATCH] async water


diff --git a/src/main/java/com/tuinity/tuinity/AsyncFluid.java b/src/main/java/com/tuinity/tuinity/AsyncFluid.java
new file mode 100644
index 0000000000000000000000000000000000000000..4ca674b58f37839d13d7219c654ed0b728a27ee2
--- /dev/null
+++ b/src/main/java/com/tuinity/tuinity/AsyncFluid.java
@@ -0,0 +1,94 @@
+package com.tuinity.tuinity;
+
+import net.minecraft.server.*;
+
+import java.util.Iterator;
+
+public class AsyncFluid implements Runnable {
+    volatile public TickListServer<FluidType> self;
+    volatile public static long allowedTick=0, ticked=0;
+    public AsyncFluid(TickListServer<FluidType> self){
+        this.self=self;
+    }
+    @Override
+    public void run() {
+        while(true){
+            if (allowedTick > ticked){
+                //WorldServer.LOGGER.warn("Inner per_AsyncEntityFluid "+ticked);
+                //tick();
+                
+                // Paper end
+                int i = self.nextTickList.size();
+
+                if (false) { // CraftBukkit
+                    throw new IllegalStateException("TickNextTick list out of sync");
+                } else {
+                    if (i > 65536) {
+                        // CraftBukkit start - If the server has too much to process over time, try to alleviate that
+                        if (i > 20 * 65536) {
+                            i = i / 20;
+                        } else {
+                            i = 65536;
+                        }
+                        // CraftBukkit end
+                    }
+
+                    ChunkProviderServer chunkproviderserver = self.f.getChunkProvider();
+                    Iterator<NextTickListEntry<FluidType>> iterator = self.nextTickList.iterator();
+
+                    //self.f.getMethodProfiler().enter("cleaning");
+
+                    //this.timingCleanup.startTiming(); // Paper
+                    NextTickListEntry nextticklistentry;
+
+                    while (i > 0 && iterator.hasNext()) {
+                        nextticklistentry = (NextTickListEntry) iterator.next();
+                        if (nextticklistentry.b > self.f.getTime()) {
+                            break;
+                        }
+
+                        if (chunkproviderserver.a(nextticklistentry.a)) {
+                            iterator.remove();
+                            self.nextTickListHash.remove(nextticklistentry);
+                            self.g.add(nextticklistentry);
+                            --i;
+                        }
+                    }
+                    //this.timingCleanup.stopTiming(); // Paper
+
+                    //this.timingTicking.startTiming(); // Paper
+                    //self.f.getMethodProfiler().exitEnter("ticking");
+
+                    while ((nextticklistentry = (NextTickListEntry) self.g.poll()) != null) {
+                        if (chunkproviderserver.a(nextticklistentry.a)) {
+                            try {
+                                self.h.add(nextticklistentry);
+                                self.i.accept(nextticklistentry);
+                            } catch (Throwable throwable) {
+                                CrashReport crashreport = CrashReport.a(throwable, "Exception while ticking");
+                                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being ticked");
+
+                                CrashReportSystemDetails.a(crashreportsystemdetails, nextticklistentry.a, (IBlockData) null);
+                                throw new ReportedException(crashreport);
+                            }
+                        } else {
+                            self.a(nextticklistentry.a, (FluidType) nextticklistentry.b(), 0); // CraftBukkit - decompile error
+                        }
+                    }
+
+                    //self.f.getMethodProfiler().exit();
+                    //this.timingTicking.stopTiming(); // Paper
+                    self.h.clear();
+                    self.g.clear();
+                }
+                ticked++;
+            }else{
+                try {Thread.sleep(10);} catch (InterruptedException e) {e.printStackTrace();}
+            }
+        }
+    }
+
+    public void tick() {
+
+    }
+}
diff --git a/src/main/java/net/minecraft/server/FluidTypeFlowing.java b/src/main/java/net/minecraft/server/FluidTypeFlowing.java
index 376dca1889f1eca4ce9993e0e067a94eb293103d..cef79981a8256ff190e47424b2af5c6be9740b88 100644
--- a/src/main/java/net/minecraft/server/FluidTypeFlowing.java
+++ b/src/main/java/net/minecraft/server/FluidTypeFlowing.java
@@ -142,6 +142,7 @@ public abstract class FluidTypeFlowing extends FluidType {
             Fluid fluid1 = this.a((IWorldReader) generatoraccess, blockposition1, iblockdata1);
 
             if (this.a(generatoraccess, blockposition, iblockdata, EnumDirection.DOWN, blockposition1, iblockdata1, generatoraccess.getFluid(blockposition1), fluid1.getType())) {
+                //Check If canSpreadTo DOWN
                 // CraftBukkit start
                 org.bukkit.block.Block source = CraftBlock.at(generatoraccess, blockposition);
                 BlockFromToEvent event = new BlockFromToEvent(source, BlockFace.DOWN);
@@ -156,7 +157,7 @@ public abstract class FluidTypeFlowing extends FluidType {
                     this.a(generatoraccess, blockposition, fluid, iblockdata);
                 }
             } else if (fluid.isSource() || !this.a((IBlockAccess) generatoraccess, fluid1.getType(), blockposition, iblockdata, blockposition1, iblockdata1)) {
-                this.a(generatoraccess, blockposition, fluid, iblockdata);
+                this.a(generatoraccess, blockposition, fluid, iblockdata); //spreadToSides
             }
 
         }
diff --git a/src/main/java/net/minecraft/server/TickListServer.java b/src/main/java/net/minecraft/server/TickListServer.java
index 3f1aa5ced697490b5481ba992cf5af5dc98b8166..1288cdf4723baa455a566d7ff7cf46c8c18190ae 100644
--- a/src/main/java/net/minecraft/server/TickListServer.java
+++ b/src/main/java/net/minecraft/server/TickListServer.java
@@ -21,12 +21,12 @@ public class TickListServer<T> implements TickList<T> {
     protected final Predicate<T> a;
     private final Function<T, MinecraftKey> b;
     private final Function<MinecraftKey, T> c;
-    private final Set<NextTickListEntry<T>> nextTickListHash = Sets.newHashSet();
-    private final TreeSet<NextTickListEntry<T>> nextTickList = Sets.newTreeSet(NextTickListEntry.a());
-    private final WorldServer f;
-    private final Queue<NextTickListEntry<T>> g = Queues.newArrayDeque();
-    private final List<NextTickListEntry<T>> h = Lists.newArrayList();
-    private final Consumer<NextTickListEntry<T>> i;
+    public final Set<NextTickListEntry<T>> nextTickListHash = Sets.newHashSet();
+    public final TreeSet<NextTickListEntry<T>> nextTickList = Sets.newTreeSet(NextTickListEntry.a());
+    public final WorldServer f;
+    public final Queue<NextTickListEntry<T>> g = Queues.newArrayDeque();
+    public final List<NextTickListEntry<T>> h = Lists.newArrayList();
+    public final Consumer<NextTickListEntry<T>> i;
 
     public TickListServer(WorldServer worldserver, Predicate<T> predicate, Function<T, MinecraftKey> function, Function<MinecraftKey, T> function1, Consumer<NextTickListEntry<T>> consumer, String timingsType) { // Paper
         this.a = predicate;
@@ -272,7 +272,6 @@ public class TickListServer<T> implements TickList<T> {
             this.nextTickListHash.add(nextticklistentry);
             this.nextTickList.add(nextticklistentry);
         }
-
     }
 
     public int a() {
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 4f8c2de9e7e5f3e78dfb5728ff9a137158b2fc01..bd62d032e479a23c4e13fab6323f570e96235811 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -9,6 +9,7 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
+import com.tuinity.tuinity.AsyncFluid;
 import it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
@@ -53,7 +54,7 @@ import org.bukkit.event.world.TimeSkipEvent;
 
 public class WorldServer extends World {
 
-    private static final Logger LOGGER = LogManager.getLogger();
+    public static final Logger LOGGER = LogManager.getLogger();
     private final List<Entity> globalEntityList = Lists.newArrayList();
     public final Int2ObjectMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap();
     private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
@@ -82,6 +83,9 @@ public class WorldServer extends World {
     protected final PersistentRaid persistentRaid;
     private final ObjectLinkedOpenHashSet<BlockActionData> I;
     private boolean ticking;
+
+    volatile public static AsyncFluid asyncFluid=null;
+
     @Nullable
     private final MobSpawnerTrader mobSpawnerTrader;
 
@@ -449,7 +453,14 @@ public class WorldServer extends World {
         timings.scheduledBlocks.startTiming(); // Spigot
         if (this.worldData.getType() != WorldType.DEBUG_ALL_BLOCK_STATES) {
             this.nextTickListBlock.b();
-            this.nextTickListFluid.b();
+
+            if(asyncFluid==null){
+                asyncFluid=new AsyncFluid(this.nextTickListFluid);
+                new Thread(asyncFluid).start();
+            }
+            asyncFluid.self=this.nextTickListFluid;
+            //this.nextTickListFluid.b();
+            AsyncFluid.allowedTick++;
         }
         timings.scheduledBlocks.stopTiming(); // Spigot
 
