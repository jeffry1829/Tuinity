From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: jeffry1829 <jeffry1829@gmail.com>
Date: Wed, 29 Apr 2020 20:59:57 +0800
Subject: [PATCH] async water


diff --git a/src/main/java/com/destroystokyo/paper/server/ticklist/PaperTickList.java b/src/main/java/com/destroystokyo/paper/server/ticklist/PaperTickList.java
index a08bfb4b3b02e998d3a6f519107e522fc58496eb..a392cb32f617ddcba68d0431f1ef3370d21f1eca 100644
--- a/src/main/java/com/destroystokyo/paper/server/ticklist/PaperTickList.java
+++ b/src/main/java/com/destroystokyo/paper/server/ticklist/PaperTickList.java
@@ -1,25 +1,10 @@
 package com.destroystokyo.paper.server.ticklist;
 
-import net.minecraft.server.MCUtil;
-import net.minecraft.server.MinecraftServer;
+import net.minecraft.server.*;
 import it.unimi.dsi.fastutil.longs.Long2ObjectMap;
 import it.unimi.dsi.fastutil.longs.Long2ObjectOpenHashMap;
 import it.unimi.dsi.fastutil.objects.ObjectRBTreeSet;
-import net.minecraft.server.BaseBlockPosition;
-import net.minecraft.server.BlockPosition;
-import net.minecraft.server.ChunkCoordIntPair;
-import net.minecraft.server.ChunkProviderServer;
-import net.minecraft.server.CrashReport;
-import net.minecraft.server.CrashReportSystemDetails;
-import net.minecraft.server.IBlockData;
-import net.minecraft.server.MinecraftKey;
-import net.minecraft.server.NBTTagList;
-import net.minecraft.server.NextTickListEntry;
-import net.minecraft.server.ReportedException;
-import net.minecraft.server.StructureBoundingBox;
-import net.minecraft.server.TickListPriority;
-import net.minecraft.server.TickListServer;
-import net.minecraft.server.WorldServer;
+
 import java.util.ArrayDeque;
 import java.util.ArrayList;
 import java.util.Collections;
@@ -41,13 +26,13 @@ public final class PaperTickList<T> extends TickListServer<T> { // extend to avo
     public static final int STATE_TICKED         = 1 << 4; // after this, it gets thrown back to unscheduled
     public static final int STATE_CANCELLED_TICK = 1 << 5; // still gets moved to unscheduled after tick
 
-    private static final int SHORT_SCHEDULE_TICK_THRESHOLD = 20 * 20 + 1; // 20 seconds
+    public static final int SHORT_SCHEDULE_TICK_THRESHOLD = 20 * 20 + 1; // 20 seconds
 
-    private final WorldServer world;
-    private final Predicate<T> excludeFromScheduling;
-    private final Function<T, MinecraftKey> getMinecraftKeyFrom;
-    private final Function<MinecraftKey, T> getObjectFronMinecraftKey;
-    private final Consumer<NextTickListEntry<T>> tickFunction;
+    public final WorldServer world;
+    public final Predicate<T> excludeFromScheduling;
+    public final Function<T, MinecraftKey> getMinecraftKeyFrom;
+    public final Function<MinecraftKey, T> getObjectFronMinecraftKey;
+    public final Consumer<NextTickListEntry<T>> tickFunction;
 
     private final co.aikar.timings.Timing timingCleanup; // Paper
     private final co.aikar.timings.Timing timingTicking; // Paper
@@ -55,27 +40,27 @@ public final class PaperTickList<T> extends TickListServer<T> { // extend to avo
 
     // note: remove ops / add ops suck on fastutil, a chained hashtable implementation would work better, but Long...
     // try to alleviate with a very small load factor
-    private final Long2ObjectOpenHashMap<ArrayList<NextTickListEntry<T>>> entriesByBlock = new Long2ObjectOpenHashMap<>(1024, 0.25f);
-    private final Long2ObjectOpenHashMap<ObjectRBTreeSet<NextTickListEntry<T>>> entriesByChunk = new Long2ObjectOpenHashMap<>(1024, 0.25f);
-    private final Long2ObjectOpenHashMap<ArrayList<NextTickListEntry<T>>> pendingChunkTickLoad = new Long2ObjectOpenHashMap<>(1024, 0.5f);
+    public final Long2ObjectOpenHashMap<ArrayList<NextTickListEntry<T>>> entriesByBlock = new Long2ObjectOpenHashMap<>(1024, 0.25f);
+    public final Long2ObjectOpenHashMap<ObjectRBTreeSet<NextTickListEntry<T>>> entriesByChunk = new Long2ObjectOpenHashMap<>(1024, 0.25f);
+    public final Long2ObjectOpenHashMap<ArrayList<NextTickListEntry<T>>> pendingChunkTickLoad = new Long2ObjectOpenHashMap<>(1024, 0.5f);
 
     // fastutil has O(1) first/last while TreeMap/TreeSet are log(n)
-    private final ObjectRBTreeSet<NextTickListEntry<T>> longScheduled = new ObjectRBTreeSet<>(TickListServerInterval.ENTRY_COMPARATOR);
+    public final ObjectRBTreeSet<NextTickListEntry<T>> longScheduled = new ObjectRBTreeSet<>(TickListServerInterval.ENTRY_COMPARATOR);
 
-    private final ArrayDeque<NextTickListEntry<T>> toTickThisTick = new ArrayDeque<>();
+    public final ArrayDeque<NextTickListEntry<T>> toTickThisTick = new ArrayDeque<>();
 
-    private final TickListServerInterval<T>[] shortScheduled = new TickListServerInterval[SHORT_SCHEDULE_TICK_THRESHOLD];
+    public final TickListServerInterval<T>[] shortScheduled = new TickListServerInterval[SHORT_SCHEDULE_TICK_THRESHOLD];
     {
         for (int i = 0, len = this.shortScheduled.length; i < len; ++i) {
             this.shortScheduled[i] = new TickListServerInterval<>();
         }
     }
-    private int shortScheduledIndex;
+    public int shortScheduledIndex;
 
-    private long nextTick;
+    public long nextTick;
 
-    private static final boolean WARN_ON_EXCESSIVE_DELAY = Boolean.getBoolean("paper.ticklist-warn-on-excessive-delay");
-    private static final long EXCESSIVE_DELAY_THRESHOLD = Long.getLong("paper.ticklist-excessive-delay-threshold", 60 * 20).longValue(); // 1 min dfl
+    public static final boolean WARN_ON_EXCESSIVE_DELAY = Boolean.getBoolean("paper.ticklist-warn-on-excessive-delay");
+    public static final long EXCESSIVE_DELAY_THRESHOLD = Long.getLong("paper.ticklist-excessive-delay-threshold", 60 * 20).longValue(); // 1 min dfl
 
     // assume index < length
     private static int getWrappedIndex(final int start, final int length, final int index) {
@@ -83,7 +68,7 @@ public final class PaperTickList<T> extends TickListServer<T> { // extend to avo
         return next < length ? next : next - length;
     }
 
-    private static int getNextIndex(final int curr, final int length) {
+    public static int getNextIndex(final int curr, final int length) {
         final int next = curr + 1;
         return next < length ? next : 0;
     }
@@ -114,7 +99,7 @@ public final class PaperTickList<T> extends TickListServer<T> { // extend to avo
         }
     }
 
-    private void addToNotTickingReady(final NextTickListEntry<T> entry) {
+    public void addToNotTickingReady(final NextTickListEntry<T> entry) {
         this.pendingChunkTickLoad.computeIfAbsent(MCUtil.getCoordinateKey(entry.getPosition()), (long keyInMap) -> {
             return new ArrayList<>();
         }).add(entry);
@@ -134,7 +119,7 @@ public final class PaperTickList<T> extends TickListServer<T> { // extend to avo
         }
     }
 
-    private void removeEntry(final NextTickListEntry<T> entry) {
+    synchronized private void removeEntry(final NextTickListEntry<T> entry) {
         entry.tickState = STATE_CANCELLED_TICK;
         // short/long scheduled will skip the entry
 
@@ -202,7 +187,7 @@ public final class PaperTickList<T> extends TickListServer<T> { // extend to avo
         }
     }
 
-    private void prepare() {
+    synchronized public void prepare() {
         final long currentTick = this.world.getTime();
 
         final ChunkProviderServer chunkProvider = this.world.getChunkProvider();
@@ -213,7 +198,7 @@ public final class PaperTickList<T> extends TickListServer<T> { // extend to avo
         // this tick
         if (this.longScheduled.isEmpty() || this.longScheduled.first().getTargetTick() > currentTick) {
             // nothing in longScheduled to worry about
-            final TickListServerInterval<T> interval = this.shortScheduled[this.shortScheduledIndex];
+            final TickListServerInterval<T> interval =  this.shortScheduled[this.shortScheduledIndex];
             for (int i = 0, len = interval.byPriority.length; i < len; ++i) {
                 for (final Iterator<NextTickListEntry<T>> iterator = interval.byPriority[i].iterator(); iterator.hasNext();) {
                     this.queueEntryForTick(iterator.next(), chunkProvider);
@@ -266,6 +251,7 @@ public final class PaperTickList<T> extends TickListServer<T> { // extend to avo
                 }
             }
         }
+        //if(this.toTickThisTick.size()!=0)WorldServer.LOGGER.warn("this.toTickThisTick.size() in PaperTickList "+this.toTickThisTick.size());
     }
 
     @Override
@@ -333,7 +319,7 @@ public final class PaperTickList<T> extends TickListServer<T> { // extend to avo
         this.timingFinished.stopTiming();
     }
 
-    private void onTickEnd(final NextTickListEntry<T> entry) {
+    public void onTickEnd(final NextTickListEntry<T> entry) {
         if (entry.tickState == STATE_CANCELLED_TICK) {
             return;
         }
@@ -553,7 +539,7 @@ public final class PaperTickList<T> extends TickListServer<T> { // extend to avo
     }
 
     @Override
-    public List<NextTickListEntry<T>> getEntriesInChunk(ChunkCoordIntPair chunkPos, boolean removeReturned, boolean excludeTicked) {
+    synchronized public List<NextTickListEntry<T>> getEntriesInChunk(ChunkCoordIntPair chunkPos, boolean removeReturned, boolean excludeTicked) {
         com.tuinity.tuinity.util.TickThread.softEnsureTickThread("async tick list get"); // Tuinity - soft async catcher
         // Vanilla DOES get the entries 2 blocks out of the chunk too, but that doesn't matter since we ignore chunks
         // not at ticking status, and ticking status requires neighbours loaded
diff --git a/src/main/java/com/tuinity/tuinity/AsyncFluid.java b/src/main/java/com/tuinity/tuinity/AsyncFluid.java
new file mode 100644
index 0000000000000000000000000000000000000000..ef6995abf7fdf8fd8000b7057f1d815f22df837f
--- /dev/null
+++ b/src/main/java/com/tuinity/tuinity/AsyncFluid.java
@@ -0,0 +1,105 @@
+package com.tuinity.tuinity;
+
+import com.destroystokyo.paper.server.ticklist.PaperTickList;
+import net.minecraft.server.*;
+
+import java.util.Iterator;
+
+public class AsyncFluid implements Runnable {
+    volatile public WorldServer self;
+    volatile public long allowedTick=0, ticked=0;
+    public AsyncFluid(WorldServer self){
+        this.self=self;
+    }
+    
+    @Override
+    public void run() {
+        while(true){
+            if (allowedTick > ticked){
+                try {
+                    long start = System.currentTimeMillis();
+                    synchronized (self.getFluidTickList()) {
+                        this.tick();
+                    }
+                    ticked++;
+                    long end = System.currentTimeMillis();
+                    if(self.worldData.getName().equals("world"))WorldServer.LOGGER.warn("tick() time elapsed: "+(end - start)+" ms");
+                }catch (Exception e){
+                    e.printStackTrace();
+                }
+            }else{
+                try {Thread.sleep(10);} catch (InterruptedException e) {
+                    e.printStackTrace();
+                }
+            }
+        }
+    }
+
+    public void tick() {
+        PaperTickList<FluidType> dis=(PaperTickList<FluidType>)self.getFluidTickList();
+        //com.tuinity.tuinity.util.TickThread.softEnsureTickThread("async tick list tick"); // Tuinity - soft async catcher
+        final ChunkProviderServer chunkProvider = dis.world.getChunkProvider();
+
+        //dis.world.getMethodProfiler().enter("cleaning");
+        //this.timingCleanup.startTiming();
+        long start = System.currentTimeMillis();
+        dis.prepare();
+        long end = System.currentTimeMillis();
+        if(self.worldData.getName().equals("world"))WorldServer.LOGGER.warn("dis.prepare() time elapsed: "+(end - start)+" ms");
+        // this must be done here in case something schedules in the tick code
+        dis.shortScheduled[dis.shortScheduledIndex].clear();
+        dis.shortScheduledIndex = dis.getNextIndex(dis.shortScheduledIndex, dis.SHORT_SCHEDULE_TICK_THRESHOLD);
+        dis.nextTick = dis.world.getTime() + 1;
+
+        //this.timingCleanup.stopTiming();
+        //this.world.getMethodProfiler().exitEnter("ticking");
+        //this.timingTicking.startTiming();
+
+        if(self.worldData.getName().equals("world"))if(dis.toTickThisTick.size()!=0)WorldServer.LOGGER.warn("dis.toTickThisTick.size() "+dis.toTickThisTick.size());
+
+        for (final NextTickListEntry<FluidType> toTick : dis.toTickThisTick) {
+            if (toTick.tickState != dis.STATE_PENDING_TICK) {
+                // onTickEnd gets called at end of tick
+                continue;
+            }
+            try {
+                if (chunkProvider.isTickingReadyMainThread(toTick.getPosition())) {
+                    toTick.tickState = dis.STATE_TICKING;
+                    dis.tickFunction.accept(toTick);
+                    if (toTick.tickState == dis.STATE_TICKING) {
+                        toTick.tickState = dis.STATE_TICKED;
+                    } // else it's STATE_CANCELLED_TICK
+                    //MinecraftServer.getServer().executeMidTickTasks(); // Tuinity - exec chunk tasks during world tick
+                } else {
+                    // re-schedule eventually
+                    toTick.tickState = dis.STATE_SCHEDULED;
+                    dis.addToNotTickingReady(toTick);
+                }
+            } catch (final Throwable thr) {
+                // start copy from TickListServer // TODO check on update
+                CrashReport crashreport = CrashReport.a(thr, "Exception while ticking");
+                CrashReportSystemDetails crashreportsystemdetails = crashreport.a("Block being ticked");
+
+                CrashReportSystemDetails.a(crashreportsystemdetails, toTick.getPosition(), (IBlockData) null);
+                throw new ReportedException(crashreport);
+                // end copy from TickListServer
+            }
+        }
+
+        //this.timingTicking.stopTiming();
+        //this.world.getMethodProfiler().exit();
+        //this.timingFinished.startTiming();
+
+        // finished ticking, actual cleanup time
+        for (int i = 0, len = dis.toTickThisTick.size(); i < len; ++i) {
+            final NextTickListEntry<FluidType> entry = dis.toTickThisTick.poll();
+            if (entry.tickState != dis.STATE_SCHEDULED) {
+                // some entries get re-scheduled due to their chunk not being loaded/at correct status, so do not
+                // call onTickEnd for them
+                dis.onTickEnd(entry);
+            }
+        }
+
+        //this.timingFinished.stopTiming();
+    }
+}
diff --git a/src/main/java/net/minecraft/server/FluidTypeFlowing.java b/src/main/java/net/minecraft/server/FluidTypeFlowing.java
index 376dca1889f1eca4ce9993e0e067a94eb293103d..cef79981a8256ff190e47424b2af5c6be9740b88 100644
--- a/src/main/java/net/minecraft/server/FluidTypeFlowing.java
+++ b/src/main/java/net/minecraft/server/FluidTypeFlowing.java
@@ -142,6 +142,7 @@ public abstract class FluidTypeFlowing extends FluidType {
             Fluid fluid1 = this.a((IWorldReader) generatoraccess, blockposition1, iblockdata1);
 
             if (this.a(generatoraccess, blockposition, iblockdata, EnumDirection.DOWN, blockposition1, iblockdata1, generatoraccess.getFluid(blockposition1), fluid1.getType())) {
+                //Check If canSpreadTo DOWN
                 // CraftBukkit start
                 org.bukkit.block.Block source = CraftBlock.at(generatoraccess, blockposition);
                 BlockFromToEvent event = new BlockFromToEvent(source, BlockFace.DOWN);
@@ -156,7 +157,7 @@ public abstract class FluidTypeFlowing extends FluidType {
                     this.a(generatoraccess, blockposition, fluid, iblockdata);
                 }
             } else if (fluid.isSource() || !this.a((IBlockAccess) generatoraccess, fluid1.getType(), blockposition, iblockdata, blockposition1, iblockdata1)) {
-                this.a(generatoraccess, blockposition, fluid, iblockdata);
+                this.a(generatoraccess, blockposition, fluid, iblockdata); //spreadToSides
             }
 
         }
diff --git a/src/main/java/net/minecraft/server/TickListServer.java b/src/main/java/net/minecraft/server/TickListServer.java
index 3f1aa5ced697490b5481ba992cf5af5dc98b8166..ba5460963aa5e990762d6e6cb411bb5ee0faf4ee 100644
--- a/src/main/java/net/minecraft/server/TickListServer.java
+++ b/src/main/java/net/minecraft/server/TickListServer.java
@@ -21,12 +21,12 @@ public class TickListServer<T> implements TickList<T> {
     protected final Predicate<T> a;
     private final Function<T, MinecraftKey> b;
     private final Function<MinecraftKey, T> c;
-    private final Set<NextTickListEntry<T>> nextTickListHash = Sets.newHashSet();
-    private final TreeSet<NextTickListEntry<T>> nextTickList = Sets.newTreeSet(NextTickListEntry.a());
-    private final WorldServer f;
-    private final Queue<NextTickListEntry<T>> g = Queues.newArrayDeque();
-    private final List<NextTickListEntry<T>> h = Lists.newArrayList();
-    private final Consumer<NextTickListEntry<T>> i;
+    public final Set<NextTickListEntry<T>> nextTickListHash = Sets.newHashSet();
+    public final TreeSet<NextTickListEntry<T>> nextTickList = Sets.newTreeSet(NextTickListEntry.a());
+    public final WorldServer f;
+    public final Queue<NextTickListEntry<T>> g = Queues.newArrayDeque();
+    public final List<NextTickListEntry<T>> h = Lists.newArrayList();
+    public final Consumer<NextTickListEntry<T>> i;
 
     public TickListServer(WorldServer worldserver, Predicate<T> predicate, Function<T, MinecraftKey> function, Function<MinecraftKey, T> function1, Consumer<NextTickListEntry<T>> consumer, String timingsType) { // Paper
         this.a = predicate;
@@ -267,12 +267,11 @@ public class TickListServer<T> implements TickList<T> {
 
     }
 
-    private void a(NextTickListEntry<T> nextticklistentry) {
+    synchronized private void a(NextTickListEntry<T> nextticklistentry) {
         if (!this.nextTickListHash.contains(nextticklistentry)) {
             this.nextTickListHash.add(nextticklistentry);
             this.nextTickList.add(nextticklistentry);
         }
-
     }
 
     public int a() {
diff --git a/src/main/java/net/minecraft/server/WorldServer.java b/src/main/java/net/minecraft/server/WorldServer.java
index 4f8c2de9e7e5f3e78dfb5728ff9a137158b2fc01..a46ab1cbfefa0691d475301935440056b1b3a5f5 100644
--- a/src/main/java/net/minecraft/server/WorldServer.java
+++ b/src/main/java/net/minecraft/server/WorldServer.java
@@ -9,6 +9,7 @@ import com.google.common.collect.Lists;
 import com.google.common.collect.Maps;
 import com.google.common.collect.Queues;
 import com.google.common.collect.Sets;
+import com.tuinity.tuinity.AsyncFluid;
 import it.unimi.dsi.fastutil.ints.Int2ObjectLinkedOpenHashMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap;
 import it.unimi.dsi.fastutil.ints.Int2ObjectMap.Entry;
@@ -53,7 +54,7 @@ import org.bukkit.event.world.TimeSkipEvent;
 
 public class WorldServer extends World {
 
-    private static final Logger LOGGER = LogManager.getLogger();
+    public static final Logger LOGGER = LogManager.getLogger();
     private final List<Entity> globalEntityList = Lists.newArrayList();
     public final Int2ObjectMap<Entity> entitiesById = new Int2ObjectLinkedOpenHashMap();
     private final Map<UUID, Entity> entitiesByUUID = Maps.newHashMap();
@@ -76,12 +77,15 @@ public class WorldServer extends World {
     private boolean everyoneSleeping;
     private int emptyTime;
     private final PortalTravelAgent portalTravelAgent;
-    private final TickListServer<Block> nextTickListBlock;
-    private final TickListServer<FluidType> nextTickListFluid;
+    private TickListServer<Block> nextTickListBlock;
+    public TickListServer<FluidType> nextTickListFluid;
     private final Set<NavigationAbstract> navigators;
     protected final PersistentRaid persistentRaid;
     private final ObjectLinkedOpenHashSet<BlockActionData> I;
     private boolean ticking;
+
+    public AsyncFluid asyncFluid=null;
+
     @Nullable
     private final MobSpawnerTrader mobSpawnerTrader;
 
@@ -181,7 +185,7 @@ public class WorldServer extends World {
     // Paper end
 
     // Paper start - rewrite ticklistserver
-    void onChunkSetTicking(int chunkX, int chunkZ) {
+    synchronized void onChunkSetTicking(int chunkX, int chunkZ) {
         ((com.destroystokyo.paper.server.ticklist.PaperTickList)this.nextTickListBlock).onChunkSetTicking(chunkX, chunkZ);
         ((com.destroystokyo.paper.server.ticklist.PaperTickList)this.nextTickListFluid).onChunkSetTicking(chunkX, chunkZ);
     }
@@ -449,7 +453,15 @@ public class WorldServer extends World {
         timings.scheduledBlocks.startTiming(); // Spigot
         if (this.worldData.getType() != WorldType.DEBUG_ALL_BLOCK_STATES) {
             this.nextTickListBlock.b();
-            this.nextTickListFluid.b();
+
+            if(asyncFluid==null){
+                asyncFluid=new AsyncFluid(this);
+                new Thread(asyncFluid).start();
+            }
+            //int j = getFluidTickList().nextTickList.size();
+            //WorldServer.LOGGER.warn("Inner per_AsyncEntityFluidAAA "+j);
+            //this.nextTickListFluid.b();
+            asyncFluid.allowedTick++;
         }
         timings.scheduledBlocks.stopTiming(); // Spigot
 
@@ -1754,7 +1766,7 @@ public class WorldServer extends World {
     }
 
     @Override
-    public TickListServer<FluidType> getFluidTickList() {
+    synchronized public TickListServer<FluidType> getFluidTickList() {
         return this.nextTickListFluid;
     }
 
